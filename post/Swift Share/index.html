<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Swift Share | Soda</title>
<link rel="shortcut icon" href="https://zcill.github.io/favicon.ico?v=1739653835433">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zcill.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Swift Share | Soda - Atom Feed" href="https://zcill.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-073HWK54DK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-073HWK54DK');
</script>

    <meta name="description" content="前段时间在公司内部做了一个Swift分享，内容是官方文档的最后五章，包括扩展、协议、泛型、访问控制以及高级运算符，主要内容是扩展和协议，后三章一笔带过~
自己也是正在学习Swift，也算是记录下自己的学习经历。
1. Extensions ..." />
    <meta name="keywords" content="Swift" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zcill.github.io">
  <img class="avatar" src="https://zcill.github.io/images/avatar.png?v=1739653835433" alt="">
  </a>
  <h1 class="site-title">
    Soda
  </h1>
  <p class="site-description">
    接近风的地方
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/zcill" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/ZcillLocke" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
        <a href="https://www.weibo.com/2969293463" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://www.zhihu.com/people/locker-zcill" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
        <a href="https://www.facebook.com/zcillcoder" target="_blank">
          <i class="ri-facebook-line"></i>
        </a>
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Swift Share
            </h2>
            <div class="post-info">
              <span>
                2017-02-17
              </span>
              <span>
                11 min read
              </span>
              
                <a href="https://zcill.github.io/tag/AboCUZu5r6/" class="post-tag">
                  # Swift
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>前段时间在公司内部做了一个Swift分享，内容是官方文档的最后五章，包括扩展、协议、泛型、访问控制以及高级运算符，主要内容是扩展和协议，后三章一笔带过~</p>
<p>自己也是正在学习Swift，也算是记录下自己的学习经历。</p>
<h3 id="1-extensions-扩展">1. Extensions 扩展</h3>
<p>扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能，与OC中的Category类似。</p>
<!--
* 扩展方法
* 扩展构造器
* 计算值属性
* 遵循协议
* 嵌套类型
-->
<p>可以扩展的功能：</p>
<ul>
<li>为已有类型添加新的实例方法和类型方法</li>
</ul>
<pre><code class="language-swift">class Person {
	
	var name = &quot;Jack&quot;
	
	func work() {
	 
	}
}

extension Person {

	func age() {		// ✅可以添加新方法
	
	}

	func work() {		// ❌不可以重写方法
	
	}
}
</code></pre>
<ul>
<li>为已有类型添加新的便利构造器</li>
</ul>
<pre><code class="language-swift">class Size {
    var width: CGFloat = 0.0
    var height: CGFloat = 0.0
    
    init(width: CGFloat, height: CGFloat) {
        self.width = width
        self.height = height
    }
}

extension Size {
    convenience init(point: CGSize) {
        
        self.init(width: point.width, height: point.height)
    }
}
</code></pre>
<ul>
<li>为已有类型添加新下标</li>
</ul>
<pre><code class="language-swift">// 为Int扩展下标
extension Int {
    subscript(_ digtalNumber: Int) -&gt; Int {
        
        return digtalNumber
    }
}

29476[3]		// 这里为 3
</code></pre>
<ul>
<li>为已有类型扩展计算型属性</li>
</ul>
<pre><code class="language-swift">extension Double {
    
    var m: Double { return self }
    var cm: Double { return self * 100.0 }
    var mm: Double { return self * 1000.0 }
    
    var invalid: Double		// ❌不可以添加存储属性
}
</code></pre>
<ul>
<li>为已有类、结构体、枚举添加新的嵌套类型</li>
</ul>
<pre><code class="language-swift">extension Int {
    enum Kind {
      //正数 负数 0
      case negative, zero, positive
    }
    var kind:Kind {
      switch self {
          case 0:
              return .zero
          case let x where x &gt; 0:
              return .positive
          default:
              return .negative
      }
    }
}

let num1 = 3
if num1.kind == .positive {
    print(&quot;\(num1) am positive&quot;)
}
</code></pre>
<ul>
<li>通过扩展遵循协议</li>
</ul>
<pre><code class="language-swift">protocol RandomGenerator {
    
    func randomBool() -&gt; Bool
}

extension SomeClass: RandomGenerator {

    func randomBool() -&gt; Bool {
        return true
    }
}
</code></pre>
<ul>
<li>为已有协议添加默认实现和新的方法实现</li>
</ul>
<pre><code class="language-swift">protocol RandomGenerator {
    
    func randomBool() -&gt; Bool
}

extension RandomGenerator {

	func randomBool() -&gt; Bool {
		return true
	}
	
	func randomInt() -&gt; Int {
		return 0
	}
}
</code></pre>
<h3 id="2protocols-协议">2.Protocols 协议</h3>
<!--
* 协议要求
* 遵循协议
* 代理模式
* 通过扩展添加、遵循协议
* 包含可选型的协议
-->
<p>协议定义一个规则去实现特定功能.类 结构体 枚举都可以遵守这个协议,并为这个协议的规则提供具体实现。</p>
<p>Apple在WWDC2015上提出一种编程范式POP(Protocol Oriented Programming)，面向协议编程。在Swift标准库中有50多种复杂不一的协议，基本上串起了整个Swift，感觉还是要项目中多实践，不然还是会沦落为语法糖，而不是一种真正的面向协议编程的思想。</p>
<p>在WWDC2015的<a href="https://developer.apple.com/videos/play/wwdc2015/408/">Session 408</a>可以找到POP的回放。</p>
<h4 id="遵循协议">遵循协议</h4>
<p>声明一个协议</p>
<pre><code class="language-swift">protocol SomeProtocol {

}
</code></pre>
<ul>
<li>自定义类、结构体遵循协议</li>
</ul>
<pre><code class="language-swift">struct SomeStruct: SomeProtocol, AnotherProtocol {

}

class SomeClass: SomeProtocol, AnotherProtocol {

}
</code></pre>
<ul>
<li>通过扩展遵循协议</li>
</ul>
<pre><code class="language-swift">extension SomeClass: SomeProtocol {

}
</code></pre>
<h4 id="协议要求">协议要求</h4>
<h5 id="方法属性">方法属性</h5>
<p>协议中的属性可以是实例属性也可以是类型属性，协议中的属性只能指定名称和类型以及可读可写。方法要求也和属性类似，可以加 <code>mutating</code> 关键字。</p>
<pre><code class="language-swift">protocol SomeProtocl2 {
    var mustBeSettable: Int { get set }             // 可读可写
    var onlyRead: Int { get }                       // 只读
    static var someTypeProperty: Int { get set }    // 类属性前面加static

    func method() -&gt; Void    
    static func classMethod() -&gt; Void
    mutating func toggle() -&gt; Void
}
</code></pre>
<p>如果有遵循协议的话，协议中的属性就必须要实现，所以如果不想实现就要用到可选型协议。</p>
<h5 id="可选协议">可选协议</h5>
<p>在Swift3中，想实现协议中的方法可选，有两种方式：</p>
<ul>
<li>协议前加 <code>@objc</code> 关键字，方法和属性前也要加<code>@objc</code>关键字 使用到可选方法或者属性时，它们的类型会自动变为可选类型</li>
</ul>
<pre><code class="language-swift">@objc protocol CounterDataSource {
    @objc optional var fixAdd: Int { get }
    @objc optional func addForCount(count: Int) -&gt; Int
}
</code></pre>
<blockquote>
<p>但是这种方法有几个缺点：</p>
<ol>
<li>只能被OC类或者带<code>@objc</code>关键字的类遵循，结构体和枚举都不能遵循</li>
<li>用到 <code>@objc</code> 关键字就免不了要与OC兼容，所以不推荐这种写法</li>
</ol>
</blockquote>
<ul>
<li>协议和方法都不加关键字，使用 Extension 扩展协议方法的默认实现。为了避免过多不必要的Objective-C兼容，一般推荐这种方法。</li>
</ul>
<pre><code class="language-swift">protocol CounterDataSource {
    
    var fixAdd: Int { get }				// optional
    
    func addForCount(count: Int) -&gt; Int	// optional
    
    func degreeCount(count: Int) -&gt; Int	// required
}

extension CounterDataSource {
    
    // 想要 fixAdd 和 addForCount(count: Int) 成为 optional 就对其进行扩展
    var fixAdd: Int {
    	// 这里对属性的getter方法进行实现
    }
    
    func addForCount(count: Int) -&gt; Int {
		// 这里对方法进行实现
    }
}

class SomeClass: CounterDataSource {
    
    // 这里只需要实现 degreeCount(count: Int) 这一个 required 方法即可
    func degreeCount(count: Int) -&gt; Int {
    	// 这里对方法进行实现
    }
}
</code></pre>
<h5 id="构造器要求">构造器要求</h5>
<p>构造方法需要遵循协议的构造器必须在方法前加上 <code>required</code> 关键字，来确保所有子类都要实现此构造器，如果是<code>final</code>修饰的类则不需要。</p>
<pre><code class="language-swift">class SomeClass: SomeProtocol {
    required init(someParameter: Int) { 
    
    }
}
</code></pre>
<h4 id="使用协议实现委托代理">使用协议实现委托代理</h4>
<p>委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>使用协议同样可以完成委托代理，和OC食用方法类似</p>
<pre><code class="language-swift">protocol SliderDelegate {
    func didDragSlider()
}

class Slider {
    
    var delegate: SliderDelegate?
    
    func drag() -&gt; Void {
        // ....
        
        delegate?.didDragSlider()       
    }
}

class ViewController: UIViewController, SliderDelegate {
    
    override func viewDidLoad() {
    	let slider = Slider()
		slider.delegate = self
		slider.drag()
    }
    
    func didDragSlider() {
        print(&quot;didDragSlider ======= &quot;)
    }   
}

</code></pre>
<p>我们在OC中会在声明中将delegate定义为<code>weak</code>，这样在delegate实际对象被释放时会被重置为nil，避免访问已被回收内存导致的crash。在Swift中想对delegate使用<code>weak</code>需要把protocol限制在类中，一种做法是将protocol声明为Objective-C的，在协议前加<code>@objc</code>关键字，因为OC的协议只有类能实现，还有一种方法就是下面说的类类型专属协议。</p>
<h4 id="类类型专属协议">类类型专属协议</h4>
<p>通过添加 <code>class</code> 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。</p>
<pre><code class="language-swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {

}
</code></pre>
<p>回头看上面的委托代理，想使用<code>weak</code>修饰delegate，只要把协议设置成类类型专属协议就可以了。</p>
<pre><code class="language-swift">protocol SliderDelegate: class {
    func didDragSlider()
}

class Slider {
    
    weak var delegate: SliderDelegate?
    
    func drag() -&gt; Void {
        // ....
        
        delegate?.didDragSlider()       
    }
}
</code></pre>
<h4 id="协议作为类型使用">协议作为类型使用</h4>
<p>协议可以像其他普通类型一样使用：</p>
<ul>
<li>作为函数、方法或者构造器中的参数类型或返回值类型</li>
<li>作为变量常量或属性的类型</li>
<li>作数组或其他容器中元素的类型</li>
</ul>
<h4 id="协议的继承">协议的继承</h4>
<p>协议能够继承一个或多个其他协议，可以在继承的基础上增加新的要求。</p>
<p>当一个类遵循一个协议时，不仅要满足该协议的所有要求，同时也要满足其父类协议的要求。</p>
<p><a href="https://onevcat.com/2016/11/pop-cocoa-1/">面向协议编程与 Cocoa 的邂逅 - OneV's Den</a></p>
<p><a href="https://realm.io/cn/news/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/">面向协议编程 - Realm.io</a></p>
<h3 id="3-generics-泛型">3. Generics 泛型</h3>
<p>泛型可以避免为类似的功能书写重复的代码，泛型参数可以看成是真实类型的占位符，当泛型被使用到时才会被真实类型替换。Swift中的Array和Dictionary都是泛型集合，可以创建包含不同类型的数组。</p>
<h4 id="为什么使用泛型">为什么使用泛型</h4>
<ul>
<li>类型安全：对于插入容器中的对象的类型都是已知的</li>
<li>减少冗余代码：对多种数据类型进行相同操作，避免潜在的代码错误</li>
<li>灵活的依赖库：作为第三方库可以暴露一些接口，避免使用这些接口的开发者(同事？)被强制使用某种固定的类型。</li>
</ul>
<h4 id="食用方法">食用方法</h4>
<p>函数、方法、属性、下标以及构造器都可以当做泛型进行处理，它们自身可以成为泛型或者存在与某个泛型类型的上下文中。</p>
<p>类型参数是定义在<code>&lt;</code>与<code>&gt;</code>紧跟着方法名后，它可以作用于：</p>
<ul>
<li>作为属性的类型</li>
<li>作为枚举体中的关联类型</li>
<li>作为某个方法的返回值或参数</li>
<li>作为构造器的参数类型</li>
<li>作为另一个泛型的类型参数，例如Array<T></li>
</ul>
<pre><code class="language-swift">// 重复添加到数组中
func duplicate&lt;T&gt;(item: T, numberOfTimes n: Int) -&gt; [T] {
        
        var buffer: [T] = []
        for _ in 0 ..&lt; n {
            buffer.append(item)
        }
        return buffer
    }
    
let obj = duplicate(item: &quot;2333&quot;, numberOfTimes: 2)

// 这里的obj是类型[String]
</code></pre>
<h3 id="4-access-control-访问控制">4. Access Control 访问控制</h3>
<h4 id="访问级别">访问级别</h4>
<p>Swift中有五种访问级别: <code>open</code>、<code>public</code>、<code>internal</code>、<code>fileprivate</code>、<code>private</code>，另外<code>private(set)</code>修饰外部只读变量，相当于OC中的<code>readonly</code></p>
<ul>
<li>open : module以外可以访问、重写或者继承。</li>
<li>public: module以外可以访问、不能重写或者继承。</li>
<li>internal(默认)：当前module可用，无需任何import</li>
<li>fileprivate: 当前文件可访问。 多用在声明extension中需要的成员变量或者方法</li>
<li>private：当前声明区域可见</li>
</ul>
<p>在实际项目中，我们的常用访问控制是这样的</p>
<pre><code class="language-swift">class CameraViewController: UIViewController {
    
    override func viewDidLoad() {
        
        startRecording()	// ✅使用fileprivate就可以在作用域外部访问到
        endRecording()		// ⛔这里编译报错，因为使用private只能在作用域内部访问到，这里无法访问到 endRecording()
    }
}

extension ViewController {
    
    fileprivate func startRecording() -&gt; Void {
    	// ...
		endRecording()	// ✅这样可以正常访问
    }
    
    private func endRecording() -&gt; Void { }
}

class WeReachability {
	// 一些共用的属性需要用Public修饰保证多个文件都可以访问到
	public enum WeReachabilityError: Error { }	
}
</code></pre>
<blockquote>
<p>Swift的设计目标之一就是一门安全的语言，所以才会有这么多访问权限，对于Swift3新出的 <code>open</code>是为了弥补public语义上的不足。</p>
<p>继承是一件危险的事情。尤其对于一个framework或者module的设计者而言。在自身的module内，类或者属性对于作者而言是清晰的，能否被继承或者override都是可控的。但是对于使用它的人，作者有时会希望传达出这个类或者属性不应该被继承或者修改。这个对应的就是 final。</p>
</blockquote>
<blockquote>
<p><code>final</code>的问题在于在标记之后，在任何地方都不能override。而对于lib的设计者而言，希望得到的是在module内可以被override，在被import到其他地方后其他用户使用的时候不能被override。</p>
</blockquote>
<blockquote>
<p>这就是 open产生的初衷。通过open和public标记区别一个元素在其他module中是只能被访问还是可以被override。</p>
</blockquote>
<h4 id="访问级别基本原则">访问级别基本原则</h4>
<ul>
<li>不可以在某个实体中定义访问更低级别的实体</li>
<li>如果 <code>private</code> 级别的类型中定义了嵌套类型，那么该嵌套类型就自动拥有private访问级别</li>
<li>子类的访问级别不能高于父类的访问级别。不过可以通过重写为继承来的类成员提供更高的访问级别。</li>
</ul>
<pre><code class="language-swift">public class A {
    private func someMethod() {
    
    }
}

internal class B: A {
    override internal func someMethod() {
    
    }
}
</code></pre>
<h3 id="5-advanced-operators-高级运算符">5. Advanced Operators 高级运算符</h3>
<!--
1. 位运算符
2. 溢出运算符
3. 运算符函数
4. 自定义运算符
-->
<p><a href="https://developer.apple.com/reference/swift/swift_standard_library_operators#//apple_ref/doc/uid/TP40016054">这里</a>可以查看官方文档完整的高级运算符</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#1-extensions-%E6%89%A9%E5%B1%95">1. Extensions 扩展</a></li>
<li><a href="#2protocols-%E5%8D%8F%E8%AE%AE">2.Protocols 协议</a>
<ul>
<li><a href="#%E9%81%B5%E5%BE%AA%E5%8D%8F%E8%AE%AE">遵循协议</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E8%A6%81%E6%B1%82">协议要求</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E5%B1%9E%E6%80%A7">方法属性</a></li>
<li><a href="#%E5%8F%AF%E9%80%89%E5%8D%8F%E8%AE%AE">可选协议</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8%E8%A6%81%E6%B1%82">构造器要求</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86">使用协议实现委托代理</a></li>
<li><a href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E4%B8%93%E5%B1%9E%E5%8D%8F%E8%AE%AE">类类型专属协议</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8">协议作为类型使用</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%A7%E6%89%BF">协议的继承</a></li>
</ul>
</li>
<li><a href="#3-generics-%E6%B3%9B%E5%9E%8B">3. Generics 泛型</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">为什么使用泛型</a></li>
<li><a href="#%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95">食用方法</a></li>
</ul>
</li>
<li><a href="#4-access-control-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">4. Access Control 访问控制</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB">访问级别</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">访问级别基本原则</a></li>
</ul>
</li>
<li><a href="#5-advanced-operators-%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6">5. Advanced Operators 高级运算符</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zcill.github.io/post/有效利用Git和CocoaPods建立自己的代码库/">
              <h3 class="post-title">
                有效利用Git和CocoaPods建立自己的代码库
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
   ❤ Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a> ｜ © 2015 - 本站由 <a href=\"https://github.com/zcill\">@Soda</a> 创建
  <a class="rss" href="https://zcill.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
